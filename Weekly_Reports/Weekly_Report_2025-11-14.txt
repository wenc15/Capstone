📝 Capstone Project — 每周工作内容总结
📅 周期：2025/11/17 – 2025/11/22

🔧 后端组（4 人）

🚀 下周团队目标

① URL monitoring

梳理 P0 对“apps/sites” 的需求，确定 demo 阶段对 URL 的最低展示要求（例如：只展示域名还是完整 URL，是否需要记录历史）。

选定至少一个浏览器作为主要支持对象（例如 Chrome），确认在 demo 环境中的实际运行方式。

在现有前台应用监控逻辑基础上，扩展获取当前浏览器活动页面信息的能力，并与现有的进程监控保持兼容。

在后端状态返回模型中增加 URL 相关字段，并将 URL 信息与当前应用名一起返回给前端。

使用 REST 工具验证 URL 信息是否能随着状态轮询稳定、正确地返回，并在发现问题时进行调整。

② Local persistence（需要重新讨论实现方式）

明确需要持久化的内容范围（例如：用户基本信息、会话记录、累计专注时长、白名单配置等），并整理成清晰的数据结构。

设计本地数据存储方案（如采用 JSON 文件、目录结构与命名方式），确保在不同运行环境下路径一致、易于管理。

在后端实现统一的数据读写层，对外提供清晰的“读配置 / 写配置 / 追加会话记录 / 读取历史记录”等接口。

将持久化逻辑与现有专注会话流程打通：在专注开始 / 结束 / 失败等关键节点，更新本地记录与累计时长。

编写简单的验证步骤（例如启动几次专注、重启后端服务），确认本地数据能被正确保存和重新读取，用于后续演示和统计展示。

③ 与 frontend 关联，使得前后端实现联动（timer，monitor）

梳理前端在 demo 阶段需要用到的所有后端接口（启动专注、停止专注、获取状态、读取用户信息或统计数据等），并统一整理参数和返回格式。

与前端协商并确定接口调用节奏（例如状态轮询的频率）以及字段命名，确保前端能直接使用后端返回的数据驱动 UI 显示。

在后端侧对现有 API 进行必要的补充或调整，使 timer 状态、监控结果（应用、URL、是否违规等）能够以稳定的形式提供给前端。

跟前端一起完成最小可用流程：前端点击按钮启动/停止专注，页面上能实时看到时间、当前应用/URL、是否违规等信息变化。

在联调过程中记录前后端交互中出现的问题（响应格式不一致、字段缺失、延迟明显等），并推动后端侧的修改，直到达到可顺畅演示的效果。

④ 后端功能整体测试（需要等待前后端联动后）

制定并执行完整的后端测试方案（待 URL monitoring、local persistence、前后端联动等主要功能完成后再集中进行），覆盖核心业务流程和边界情况。

使用 focus-api.rest 或 Postman 等工具，对正常流程、违规流程、异常参数（缺少字段、非法值、极端时间等）进行系统化测试，并记录测试结果。

在前后端联动完成后，与前端一起走完整 demo 流程：从打开应用、启动专注、模拟违规、查看状态、结束专注，到查看记录或统计，逐步确认每个关键点的表现。

对测试过程中发现的问题进行分类（功能错误、性能问题、交互不一致等），整理为可执行的修复清单，并跟踪到问题关闭。

在需要时补充或调整简单的日志输出，方便在演示前后快速定位和复查问题。

⑤ 调整 README 文件与 backend 整体 structure

评估当前 backend 目录结构与实际运行方式的差异，特别是内容集中在 src 中、以及 bin / obj 出现在 backend 主目录外部等问题，整理出目标结构。

调整 backend 目录与项目设置，使 backend/ 内部的组织更清晰，例如统一在 src/ 下放置源码，将 data/、docs/ 等目录划分清楚，避免编译产物散落在项目主目录。

更新 README.md，同步新的文件结构与启动方式，包括：如何运行后端、如何使用测试文件、后端提供了哪些主要功能（URL monitoring、local persistence、前后端联动等）。

在 README 中补充面向团队成员或演示场景的说明：例如“如何本地快速跑起来”、“如何配合前端完成一次完整 demo”、“需要注意避免提交的文件或本地配置”。

✅ Backend 本周进展

完成专注计时（Focus Session）核心逻辑开发，包括启动、停止与倒计时流程，系统可稳定维护当前会话状态并实时计算剩余时间。

实现前台应用监控（Active App Monitoring），可识别当前使用的程序并基于白名单判断违规行为，同时支持可配置的宽限期与自动失败判定。

完善状态返回数据结构，前端可通过统一接口获取专注状态、剩余时间、当前应用、违规情况及失败原因等完整信息。

建立后端 API 调试环境，包括 Swagger 文档与 VS Code 的 focus-api.rest 测试文件，保证核心功能可直接运行与验证。

完成后端基础环境搭建与内部功能测试。

🔧 前端组（2 人）

🚀 下周团队目标

① 前端计时器与后端计时逻辑完全联动（timer integration）（和后端联动成员合作完成，具体操作还需更改）

将前端的 start / give up 操作切换为调用后端 API，实现由后端驱动的统一计时逻辑。

将前端计时器 UI 状态重构为实时读取后端 status 返回值（剩余时间、是否运行、是否暂停等）。

确保前端界面在整个 session 期间可以持续轮询后端，正确显示 timer 数值变化与状态转换。

测试完整流程：启动 → 运行 → 恢复 → give up → 正常结束，并确保 UI 与后端保持同步。

② 监控展示联动（monitor integration）（和后端联动与monitor实现成员合作完成）

在前端界面中展示后端返回的当前前台应用信息（app name）。

若后端提供 URL 信息，则在监控区域同步呈现当前浏览器 URL 或域名。

在 UI 中反映后端识别的违规状态（是否 violating、violation time 等）。

在用户违规超过宽限期导致 session 失败时，前端能实时呈现失败状态与相关提示。

③ 删除主界面notes part

由于全部功能由后端进行实现，所以删除原有的notes part

④ Stats 页面改为读取后端真实数据（stats integration）

将summary内数据与最近 sessions 列表由前端 mock 数据迁移为从后端持久化内容中读取。

从后端获取总 sessions 数、总专注时间，并在 UI 中正确展示。

将上一轮 session 的 notes 信息改为实时从后端读取。

构建最近七天专注时间所需的图表数据（后端提供原始记录或由前端计算）。

验证所有统计项目在切换页面、刷新页面时数据仍然一致。

⑤ Widget 与主计时器联动（widget integration）

整体删除暂停（pause）功能，新增放弃（give up）逻辑：在点击start的10秒内可以选择放弃本次专注，以防止误触带来的失败记录（与后续的失败惩罚，代币成就获取相关）。

将 widget 的显示内容（剩余时间、运行状态）与主计时器保持同步，由后端状态统一驱动。

将 widget 的暂停/恢复操作与主计时器连接，保证两者逻辑一致。

完成 widget 在应用内拖拽的稳定性测试，并确保不会影响主界面状态。

若 P0 演示有需要，确保 widget 在切换到其他页面时仍能正确显示计时状态。

⑥ 用户体验与界面交互完善（UX polishing）

对接后端返回的失败原因与提示信息，在 UI 上进行明显反馈。

增加对错误状态的处理（网络问题、后端崩溃、未启动后端等场景）。

检查并修复导航路径，确保主页 → stats → notes → widget 等页面切换顺畅。

修复stats页面柱状图显示bug问题

✅ ① Frontend 本周进展

完成主界面基础布局与交互，包括可拖拽时间轴的计时器原型（start / pause / give up），并搭建卡牌系统、天气模块以及 session summary 的界面占位内容。

开发 stats 页面，支持展示最近专注记录、总 sessions 数、累计专注时长、上一轮专注的 notes，以及最近七天的专注时长柱状图。

完成 notes 板块界面，并与后端监控信息联动，可在 session 结束后展示本次专注期间使用过的应用记录。

pets 页面完成基础 placeholder，为后续交互与动画预留结构。

widget 原型完成，包含简易计时显示与暂停功能，并支持在应用窗口内拖拽（暂未与主计时器逻辑整合）。

🔧 待商议事项
① 代码文件更新说明规范（File Header Update Log）

所有代码文件在修改时，必须在文件顶部添加更新说明，记录本次改动的基本信息。
说明内容采用倒序方式（最新的更新写在最上方）。

每次修改必须包含：

更新日期（YYYY-MM-DD）

更新人（GitHub 用户名或真实姓名）

简要更新内容（1–2 行即可）

e.g.（C# 文件示例）：

// [2025-11-14] Updated by Yuexi Sun
// - Added URL monitoring field to FocusStatusResponse
// - Adjusted timer status reset logic

// [2025-11-10] Updated by Alice
// - Initial implementation of FocusSessionService

② 分支管理与开发流程（Feature Branch Workflow）

为避免多人同时修改导致冲突，所有开发必须使用功能分支（feature branch），并遵循以下流程：

分支类型

main：稳定、可演示的最终版本

backend：后端集成分支（可选）

frontend：前端集成分支（可选）

feat/...：功能分支（所有新开发必须基于此）

e.g. 
feat/backend/url-monitoring
feat/frontend/stats-integration
feat/backend/local-persistence-jy

功能开发流程：

从对应团队分支拉取最新代码

git checkout backend   或   git checkout frontend
git pull

新建功能分支

git checkout -b feat/backend/url-monitoring

在该分支完成所有开发与自测。

开发完成后，通过 Pull Request（PR）申请合并回团队分支（backend/frontend）。

PR 合并后删除该功能分支（本地与远程）。

③ 每周例会与每周任务提交时间

✔ 每周固定例会时间

周日晚上 7 点 （线上）

✔ 每周个人工作更新提交截止时间

每周六晚上 7 点前

④ GitHub Pull Request 合并流程

示例：

所有分支合并必须通过 Pull Request 完成，流程如下：

标准 PR 合并流程：

开发者完成功能后提交 PR

标题需清晰说明本次功能，如：
“Add URL Monitoring Backend Logic”

在 PR 中写明本次修改内容（3–6 行即可）

至少 1 名组员进行 Code Review

检查是否影响其他模块

检查逻辑是否清晰

检查文件结构与命名是否符合项目规范

Review 通过后方可合并到目标分支

合并后删除本次功能分支（保持分支列表整洁）

冲突处理规定：

若出现冲突，由 PR 提交者本人负责修复。

冲突处理完成后需重新请求 Review。

main 分支合并规则：

只有团队负责人或指定成员负责将 backend/frontend 合并到 main。

main 仅包含“可演示、稳定”的内容，不进行开发。

